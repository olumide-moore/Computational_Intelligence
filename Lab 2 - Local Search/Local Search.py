
from pandas import read_csv
import time
import copy
from random import shuffle
from math import sqrt
# from TSPbase import random_route, create_adjcency_matrix, evaluate_fitness



def random_route(tsp_instance):
    """
    param tsp_instance: a given tsp instance
    return: list of random order of cities to visit e.g. [0,1,2,3] or [2,3,1,0] given count=4
    """
    route=list(range(len(tsp_instance)))
    shuffle(route)
    return route

def create_adjcency_matrix(points):
    """
    param points: 2D-list of points in the form [[x1,y1],[x2,y2],...] each representing the x,y coordinate of a city
    return: 2D adjacency matrix i.e. the distance between each city in form [[0,p0-p1,p0-p2,...],[p1-p0,0,p1-p2,...],...,[pn-p0,pn-p1,...,0]]
    """
    n_cities=len(points)
    adjacency_matrix=[[0 for i in range(n_cities)] for j in range(n_cities)] #Create a matrix of size n_cities*n_cities
    for i in range(len(points)): #Populate the matrix with the distances
        for j in range(len(points)):
            if i!=j:
                x=(float(points[j][0])-float(points[i][0]))**2 #(xⱼ-xᵢ)²
                y=(float(points[j][1])-float(points[i][1]))**2 #(yⱼ-yᵢ)²
                adjacency_matrix[i][j]=sqrt(x+y) #√(xⱼ-xᵢ)²+(yⱼ-yᵢ)²
    return adjacency_matrix

def evaluate_fitness(route, adjacency_matrix):
    """
    param route: list of order of cities to visit
    param adjacency_matrix: 2D adjacency matrix of cities i.e. the distance between each city in form [[0,p0-p1,p0-p2,...],[p1-p0,0,p1-p2,...],...,[pn-p0,pn-p1,...,0]]
    return: float/int fitness of the route
    """
    fitness=0 
    for i in range(len(route)-1):  #Loop till the second last city as the last city will be connected to the first city
        fitness+=adjacency_matrix[route[i]][route[i+1]] #Add the distance fitness between the current city and the next city
    fitness+=adjacency_matrix[route[-1]][route[0]] #Add the distance between the last city and the first city
    # return f"Route {route}  fitness: {fitness}"
    return fitness



def random_timed_tsp(tsp_instance,limit):
    '''
    returns the best route and fitness found within the time limit
    This uses the random search algorithm
    Randomly generate a route and evaluate it. If it is better than the current best route, update the best route.
    '''
    start_time=time.time()
    
    best_fitness= float('inf')
    best_route= None
    while time.time()-start_time<limit:
        route=random_route(tsp_instance)
        cur_fitness=evaluate_fitness(route, tsp_instance)
        if cur_fitness<best_fitness:
            best_fitness, best_route=cur_fitness, route
    return best_route, best_fitness

def city_swap_neighbourhood(route):
    """
    route: a single route
    return: list of all possible routes that can be generated by swapping any two cities in the route
    """
    # print(route)
    neighbours= []
    for i in range(1,len((route))-1): #Loop through all cities except the first city and the last city
        for j in range(i+1,len(route)): #Loop from this city to the last city
            new_route= copy.deepcopy(route) #Create a copy of the route
            new_route[i], new_route[j] = new_route[j], new_route[i] #Swap the cities
            neighbours.append(new_route)        
    return neighbours

def two_opt_swap(route):
    """
    return: list of all possible routes that can be generated by swapping non-adjacent cities in the route
    """
    neighbours = []
    n=len(route)
    for i in range(1,n-2):
        for j in range(i+2,n): #2nd node is non-adjacent cities
            new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:] #Perform 2-opt swap
            neighbours.append(new_route)
    return neighbours

def get_best_neighbour(neighbourhood):
    '''
    returns the best neighbour and its fitness
    '''
    fitnesses = [evaluate_fitness(neighbour, adjacency_matrix) for neighbour in neighbourhood]
    best_fitness = min(fitnesses)
    return neighbourhood[fitnesses.index(best_fitness)], best_fitness

#Put it all together
def tsp_localsearch_time_based(limit, adjacency_matrix, initialiser, neighbourhood_func, step_func):
    '''
    This function implements the local search algorithm with time based termination
    - limit: time limit in seconds
    - adjacency_matrix: adjacency matrix of the tsp
    - initialiser: function that initialises a route
    - neighbourhood_func: function that returns the neighbourhood of the route
    - step_func: function that returns the best neighbour

    Returns the best route and fitness found within the time limit
    '''
    start=time.time()
    #Initialise the route
    route=initialiser(adjacency_matrix) 

    best_fitness=evaluate_fitness(route, adjacency_matrix)
    print(f"Cost of initialiazed tour: {best_fitness}")
    best_route=route
    while time.time()-start<limit: #Loop till the time limit
        neighbourhood= neighbourhood_func(route) #Get the neighbourhood of the current route
        route,cur_fitness= step_func(neighbourhood)#Get the best neighbour
        if cur_fitness<best_fitness:     #If the neighbour is better than the current route, update the current route
            best_route, best_fitness=route, cur_fitness
            print(best_fitness)
        else: #local optimum reached
            route=initialiser(adjacency_matrix) #Start with a new route
    return best_route, best_fitness  

# adjacency_matrix=  [[0, 20, 42, 35],
#                     [20, 0, 30, 34],
#                     [42, 30, 0, 12],
#                     [35, 34, 12, 0]]

#Ulysses16 csv
# ulysses16_coords = read_csv('ulysses16.csv',header=0).values
# test2= read_csv('test(2).csv',header=0).values
cities82_9= read_csv('cities82_9.csv',header=0).values
adjacency_matrix= create_adjcency_matrix(cities82_9) #Create adjancency matrix of points


limit=20 #Time limit in seconds
initialiser=random_route
neighbourhood_func=two_opt_swap
step_func=get_best_neighbour
print(f"Best route and fitness found within {limit} seconds using {neighbourhood_func.__name__} and {step_func.__name__} is:")
print(tsp_localsearch_time_based(limit, adjacency_matrix, initialiser, neighbourhood_func, step_func))


# print(random_timed_tsp(adjacency_matrix,limit))

##How the quality of the two solutions compare
#Random time-based search is simple but for larger instances, it becomes less effective as the probability of finding a good solution decreases.

#Local search can be quite effective, with its focus on exploiting the local neighbourhood, 
#there is no guarantee of finding the global optimum solution, this becomes a challenge for a large instance. 


#The 2-opt swap non-adjacent neighbourhood, due to reversing the order of the cities between two non-adjacent cities,
#it is able to explore a broader region of the search space, which allows the algorithm to escape from local optima more easily than swap neighbourhood.


#For 3 seconds
##The time based random search does not guarantee a good solution within the time limit after running it even with 10s. (81-85)
##The local search with restart guarantees a good solution within the time limit. (73-78)

